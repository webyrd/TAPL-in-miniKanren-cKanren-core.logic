;;; This file was generated by writeminikanren.pl
;;; Generated at 2006-11-07 00:11:44

(define-syntax lambdag@
  (syntax-rules ()
    ((_ (p) e) (lambda (p) e))))

(define-syntax lambdaf@
  (syntax-rules ()
    ((_ () e) (lambda () e))))

(define-syntax run*
  (syntax-rules ()
    ((_ (x) g ...) (run #f (x) g ...))))


(define-syntax rhs
  (syntax-rules ()
    ((_ x) (cdr x))))

(define-syntax lhs
  (syntax-rules ()
    ((_ x) (car x))))

(define-syntax size-s
  (syntax-rules ()
    ((_ x) (length x))))

(define-syntax var
  (syntax-rules ()
    ((_ x) (vector x))))

(define-syntax var?
  (syntax-rules ()
    ((_ x) (vector? x))))

(define-syntax pkg
  (syntax-rules ()
    ((_ s c*) (cons s c*))))

(define-syntax sof
  (syntax-rules ()
    ((_ p) (car p))))

(define-syntax cof
  (syntax-rules ()
    ((_ p) (cdr p))))


(define empty-s '())

(define empty-c '())

(define empty-p (pkg empty-s empty-c))

(define walk
  (lambda (v s)
    (cond
      ((var? v)
       (let ((a (assq v s)))
         (cond
           (a (walk (rhs a) s))
           (else v))))
      (else v))))

(define ext-s
  (lambda (x v s)
    (cons `(,x . ,v) s)))
 
(define unify*
  (lambda (u v p)
    (let ((s (sof p)) (c* (cof p)))
      (let ((s^ (unify u v s)))
        (cond
          (s^ (cond
                ((eq? s^ s) p)
                ((ormap
                   (lambda (c)
                     (constraint? c s^))
                   c*)
                 #f)
                (else (pkg s^ c*))))
          (else #f))))))
 
(define constraint?
  (lambda (c s)
    (case (car c)
      ((never-pair)
       (pair? (walk (cadr c) s)))
      ((never-equal)
       (let ((u (cadr c))
             (v (caddr c)))
         (term-equal?
           (walk* u s)
           (walk* v s)))))))

(define unify
  (lambda (u v s)
    (let ((u (walk u s))
          (v (walk v s)))
      (cond
        ((eq? u v) s)
        ((var? u) (ext-s-check u v s))
        ((var? v) (ext-s-check v u s))
        ((and (pair? u) (pair? v))
         (let ((s (unify (car u) (car v) s)))
           (and s 
             (unify (cdr u) (cdr v) s))))
        ((equal? u v) s)
        (else #f)))))
 
(define ext-s-check
  (lambda (x v s)
    (cond
      ((occurs-check x v s) #f)
      (else (ext-s x v s)))))

(define occurs-check
  (lambda (x v s)
    (let ((v (walk v s)))
      (cond
        ((var? v) (eq? v x))
        ((pair? v) 
         (or 
           (occurs-check x (car v) s)
           (occurs-check x (cdr v) s)))
        (else #f)))))

(define never-pair*
  (lambda (c p)
    (let ((c (walk c (sof p))))
      (cond
        ((var? c) (pkg/c `(never-pair ,c) p))
        ((pair? c) #f)
        (else p)))))
 
(define pkg/c
  (lambda (c p)
    (pkg (sof p) (ext-c c (cof p)))))
 
(define ext-c
  (lambda (c c*)
    (cons c c*)))

(define never-equal*
  (lambda (u v p)
    (let ((s (unify u v (sof p))))
      (cond
        ((not s) p)
        (else 
          (let ((u (walk* u (sof p)))
                (v (walk* v (sof p))))
            (cond
              ((term-equal? u v) #f)
              (else 
                (pkg/c
                  `(never-equal ,u ,v)
                  p)))))))))

(define term-equal?
  (lambda (u v)
    (cond
      ((eq? u v) #t)
      ((or (var? u) (var? v)) #f)
      ((and (pair? u) (pair? v))
       (and (term-equal? (car u) (car v))
            (term-equal? (cdr u) (cdr v))))
      (else (equal? u v)))))

(define walk*
  (lambda (w s)
    (let ((v (walk w s)))
      (cond
        ((var? v) v)
        ((pair? v)
         (cons
           (walk* (car v) s)
           (walk* (cdr v) s)))
        (else v)))))

(define reify-s
  (lambda (v s)
    (let ((v (walk v s)))
      (cond
        ((var? v)
         (ext-s v (reify-name (size-s s)) s))
        ((pair? v) (reify-s (cdr v)
                     (reify-s (car v) s)))
        (else s)))))

(define reify-name
  (lambda (n)
    (string->symbol
      (string-append "_" "." (number->string n)))))

(define reify
  (lambda (v p)
    (let ((s (sof p)) (c* (cof p)))
      (let ((v (walk* v s))
            (wc* (walk* c* s)))
        (let ((s (reify-s v empty-s)))
          (let ((c* (get-c* wc* s)))
            (cond
              ((null? c*) (walk* v s))
              (else 
                (let ((s^ (reify-s c* s))
                      (c^ (walk* c* s)))
                  (let ((d (clean c^)))
                    (let ((v (walk* v s))
                          (r (walk* d s^)))
                      `(,v : ,r))))))))))))
 
(define clean
  (lambda (c*)
    (let loop ((c (car c*)) (c* (cdr c*)))
      (cond
        ((null? c*) (cons c '()))
        ((ormap 
           (lambda (c^) (compare? c c^))
           c*) 
         (loop (car c*) (cdr c*)))
        (else 
          (cons c 
            (loop (car c*) (cdr c*))))))))
 
(define compare?
  (lambda (c c^)
    (cond
      ((term-equal? c c^) #t)
      (else
        (and
          (eq? (car c) 'never-equal)
          (eq? (car c^) 'never-equal)
          (term-equal?
            (reverse (cdr c))
            (cdr c^)))))))

(define get-c*
  (lambda (wc* s)
    (cond
      ((null? wc*) '())
      ((okay-c (car wc*) s)
       => 
       (lambda (c) 
         (cons c
           (get-c* (cdr wc*) s))))
      (else 
        (get-c* (cdr wc*) s)))))
 
(define okay-c
  (lambda (wc s)
    (case (car wc)
      ((never-pair)
       (let ((v (cadr wc))) 
         (and
           (var? v)
           (not (var? (walk v s)))
           wc)))
      ((never-equal)
       (let ((u (cadr wc))
             (v (caddr wc)))
         (and
           (unify u v empty-s)
           (or (anyvar? u s)
               (anyvar? v s))
           wc))))))
 
(define anyvar?
  (lambda (v s)
    (cond
      ((var? v) (not (var? (walk v s))))
      ((pair? v) (or (anyvar? (car v) s)
                     (anyvar? (cdr v) s)))
      (else #f))))

(define ==-unchecked
  (lambda (v w)
    (lambdag@ (p)
      (unify*-unchecked v w p))))


(define mzero (lambda () #f))
(define unit (lambda (a) a))
(define choice (lambda (a f) (cons a f)))
 
(define-syntax inc 
  (syntax-rules () 
    ((_ e) (lambdaf@ () e))))
 
(define-syntax case-inf
  (syntax-rules ()
    ((_ e =0 ((a^) =1) ((a f) >=1) ((f^) ?))
     (let ((a-inf e))
       (cond
         ((not a-inf) =0)
         ((procedure? a-inf) 
          (let ((f^ a-inf)) ?))
         ((and (pair? a-inf)
               (procedure? (cdr a-inf)))
          (let ((a (car a-inf)) (f (cdr a-inf))) 
            >=1))
         (else (let ((a^ a-inf)) =1)))))))

(define-syntax run
  (syntax-rules ()
    ((_ n (x) g0 g^ ...)
     (take n (lambdaf@ ()
               ((fresh (x)
                  (lambdag@ (p)
                    (bind* (g0 p) g^ ... 
                      (lambdag@ (p)
                        (cons (reify x p) '())))))
                empty-p))))))
 
(define take
  (lambda (n f)
    (if (and n (zero? n))
      '()
      (case-inf (f)
        '()
        ((a) a)
        ((a f) 
         (cons (car a) (take (and n (- n 1)) f)))
        ((f) (take n f))))))

(define == 
  (lambda (u v)
    (lambdag@ (p)
      (unify* u v p))))
 
(define never-equalo 
  (lambda (u v)
    (lambdag@ (p)
      (never-equal* u v p))))
 
(define never-pairo 
  (lambda (u)
    (lambdag@ (p)
      (never-pair* u p))))

(define-syntax fresh
  (syntax-rules ()
    ((_ (x ...) g0 g ...)
     (lambdag@ (p)
       (let ((x (var 'x)) ...)
         (bind* (g0 p) g ...))))))
 
(define-syntax bind*
  (syntax-rules ()
    ((_ e) e)
    ((_ e g0 g ...)
     (let ((a-inf e))
       (and a-inf (bind* (bind a-inf g0) g ...))))))
 
(define bind
  (lambda (a-inf g)
    (case-inf a-inf
      (mzero)
      ((a) (g a))
      ((a f) (mplus (g a) (lambdaf@ () (bind (f) g))))
      ((f) (inc (bind (f) g))))))

(define-syntax conde
  (syntax-rules (else)
    ((_ (g0 g ...) (g1 g^ ...) ...)
     (lambdag@ (p)
       (inc
         (mplus* 
           (bind* (g0 p) g ...)
           (bind* (g1 p) g^ ...) ...))))))
 
(define-syntax mplus*
  (syntax-rules ()
    ((_ e) e)
    ((_ e0 e ...) 
     (mplus e0 (lambdaf@ () (mplus* e ...))))))
 
(define mplus
  (lambda (a-inf f)
    (case-inf a-inf
      (f)
      ((a) (choice a f))
      ((a f^) (choice a (lambdaf@ () (mplus (f) f^))))
      ((f^) (inc (mplus (f) f^))))))


(define-syntax conda
  (syntax-rules ()
    ((_ (g0 g ...) (g1 g^ ...) ...)
     (lambdag@ (p)
       (ifa ((g0 p) g ...) 
            ((g1 p) g^ ...) ...)))))
 
(define-syntax ifa
  (syntax-rules ()
    ((_) (mzero))
    ((_ (e g ...) b ...)
     (let loop ((a-inf e))
       (case-inf a-inf
         (ifa b ...)
         ((a) (bind* a-inf g ...))
         ((a f) (bind* a-inf g ...))
         ((f) (inc (loop (f)))))))))

(define-syntax condu
  (syntax-rules ()
    ((_ (g0 g ...) (g1 g^ ...) ...)
     (lambdag@ (p)
       (ifu ((g0 p) g ...) 
            ((g1 p) g^ ...) ...)))))
 
(define-syntax ifu
  (syntax-rules ()
    ((_) (mzero))
    ((_ (e g ...) b ...)
     (let loop ((a-inf e))
       (case-inf a-inf
         (ifu b ...)
         ((a) (bind* a-inf g ...))
         ((a f) (bind* (unit a) g ...))
         ((f) (inc (loop (f)))))))))


(define-syntax project 
  (syntax-rules ()                                                              
    ((_ (x ...) g g* ...)  
     (lambdag@ (p)
       (let ((s (sof p)))
         (let ((x (walk* x s)) ...)
           ((fresh () g g* ...) p)))))))


(define succeed (== #f #f))

(define fail (== #f #t))


(define onceo
  (lambda (g)
    (condu
      (g succeed)
      ((== #f #f) fail))))
